using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace SwitchController
{
    /// <summary>
    /// Writes MacroFrame list to human-readable text format
    /// </summary>
    public static class MacroWriter
    {
        /// <summary>
        /// Writes macro frames to a file in text format
        /// </summary>
        public static void WriteFile(string filePath, List<MacroFrame> frames)
        {
            var content = WriteToString(frames);
            File.WriteAllText(filePath, content);
        }

        /// <summary>
        /// Writes macro frames to a string in text format
        /// </summary>
        public static string WriteToString(List<MacroFrame> frames)
        {
            if (frames == null || frames.Count == 0)
                return "# Empty macro\n";

            var sb = new StringBuilder();
            sb.AppendLine("# Macro generated by SwitchController");
            sb.AppendLine($"# Total frames: {frames.Count}");

            if (frames.Count > 0)
            {
                long totalDurationMs = frames[frames.Count - 1].TimestampMs;
                double totalDurationSec = totalDurationMs / 1000.0;
                sb.AppendLine($"# Duration: {totalDurationSec:F2}s");
            }

            sb.AppendLine();

            // Convert frames to commands
            for (int i = 0; i < frames.Count; i++)
            {
                var frame = frames[i];
                long duration;

                // Calculate duration until next frame (or 0 for last frame)
                if (i < frames.Count - 1)
                {
                    duration = frames[i + 1].TimestampMs - frame.TimestampMs;
                }
                else
                {
                    // Last frame - typically a release frame with 0 duration, skip it
                    if (IsNeutralPacket(frame.Packet))
                        break;
                    duration = 0;
                }

                // Skip frames with 0 duration unless they're the only frame
                if (duration == 0 && frames.Count > 1)
                    continue;

                // Decode packet and write command
                string command = DecodePacket(frame.Packet, duration);
                sb.AppendLine(command);
            }

            return sb.ToString();
        }

        /// <summary>
        /// Checks if a packet is neutral (no inputs)
        /// </summary>
        private static bool IsNeutralPacket(byte[] packet)
        {
            ushort buttons = (ushort)((packet[0] << 8) | packet[1]);
            byte hat = packet[2];
            byte lx = packet[3];
            byte ly = packet[4];
            byte rx = packet[5];
            byte ry = packet[6];

            return buttons == 0 &&
                   hat == SwitchControllerConstants.HAT_NEUTRAL &&
                   lx == 128 && ly == 128 &&
                   rx == 128 && ry == 128;
        }

        /// <summary>
        /// Decodes a packet into a human-readable command string
        /// </summary>
        private static string DecodePacket(byte[] packet, long durationMs)
        {
            var inputs = new List<string>();

            // Decode buttons
            ushort buttons = (ushort)((packet[0] << 8) | packet[1]);
            foreach (var kvp in MacroFormat.ButtonNameMap)
            {
                if ((buttons & kvp.Key) != 0)
                {
                    inputs.Add(kvp.Value);
                }
            }

            // Decode D-Pad (HAT)
            byte hat = packet[2];
            if (MacroFormat.DPadNameMap.TryGetValue(hat, out string? hatName))
            {
                inputs.Add(hatName);
            }

            // Decode left stick
            byte lx = packet[3];
            byte ly = packet[4];
            string leftStickStr = MacroFormat.FormatStickValue(lx, ly, true);
            if (!string.IsNullOrEmpty(leftStickStr))
            {
                inputs.Add(leftStickStr);
            }

            // Decode right stick
            byte rx = packet[5];
            byte ry = packet[6];
            string rightStickStr = MacroFormat.FormatStickValue(rx, ry, false);
            if (!string.IsNullOrEmpty(rightStickStr))
            {
                inputs.Add(rightStickStr);
            }

            // Format output
            if (inputs.Count == 0)
            {
                return $"Wait,{durationMs}";
            }

            // Sort inputs for consistent output (buttons first, then D-Pad, then sticks)
            inputs = SortInputs(inputs);

            string inputsStr = string.Join("+", inputs);
            return $"{inputsStr},{durationMs}";
        }

        /// <summary>
        /// Sorts inputs in a logical order for readability
        /// </summary>
        private static List<string> SortInputs(List<string> inputs)
        {
            var buttons = new List<string>();
            var dpad = new List<string>();
            var sticks = new List<string>();

            foreach (var input in inputs)
            {
                if (MacroFormat.ButtonMap.ContainsKey(input))
                {
                    buttons.Add(input);
                }
                else if (MacroFormat.DPadMap.ContainsKey(input))
                {
                    dpad.Add(input);
                }
                else
                {
                    sticks.Add(input);
                }
            }

            // Sort buttons in a specific order (face buttons, shoulders, system)
            buttons = SortButtons(buttons);

            // Combine in order: buttons, D-Pad, sticks
            var result = new List<string>();
            result.AddRange(buttons);
            result.AddRange(dpad);
            result.AddRange(sticks);
            return result;
        }

        /// <summary>
        /// Sorts buttons in a logical order
        /// </summary>
        private static List<string> SortButtons(List<string> buttons)
        {
            var order = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
            {
                { "Y", 1 }, { "B", 2 }, { "A", 3 }, { "X", 4 },
                { "L", 5 }, { "R", 6 }, { "ZL", 7 }, { "ZR", 8 },
                { "LClick", 9 }, { "RClick", 10 },
                { "Minus", 11 }, { "Plus", 12 },
                { "Home", 13 }, { "Capture", 14 }
            };

            return buttons.OrderBy(b => order.ContainsKey(b) ? order[b] : 99).ToList();
        }

        /// <summary>
        /// Optimizes a frame list by merging consecutive identical frames
        /// This can reduce the size of recorded macros
        /// </summary>
        public static List<MacroFrame> OptimizeFrames(List<MacroFrame> frames)
        {
            if (frames == null)
                return new List<MacroFrame>();
            if (frames.Count <= 1)
                return frames;

            var optimized = new List<MacroFrame>();
            MacroFrame? currentFrame = null;

            foreach (var frame in frames)
            {
                if (currentFrame == null)
                {
                    currentFrame = new MacroFrame
                    {
                        TimestampMs = frame.TimestampMs,
                        Packet = (byte[])frame.Packet.Clone()
                    };
                    continue;
                }

                // Check if packets are identical
                bool identical = true;
                for (int i = 0; i < 8; i++)
                {
                    if (frame.Packet[i] != currentFrame.Packet[i])
                    {
                        identical = false;
                        break;
                    }
                }

                if (!identical)
                {
                    // Different packet - save current and start new
                    optimized.Add(currentFrame);
                    currentFrame = new MacroFrame
                    {
                        TimestampMs = frame.TimestampMs,
                        Packet = (byte[])frame.Packet.Clone()
                    };
                }
                // If identical, we just skip this frame (effectively merging it with the current)
            }

            // Add the last frame
            if (currentFrame != null)
            {
                optimized.Add(currentFrame);
            }

            return optimized;
        }
    }
}
