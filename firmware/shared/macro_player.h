#ifndef SHARED_MACRO_PLAYER_H
#define SHARED_MACRO_PLAYER_H

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/*
 * Embedded macro frame structure.
 * This must match the structure generated by macro_to_c.py.
 */
#ifndef EMBEDDED_MACRO_FRAME_T_DEFINED
#define EMBEDDED_MACRO_FRAME_T_DEFINED
typedef struct {
    uint32_t timestamp_ms;  // Timestamp in milliseconds
    uint8_t packet[8];      // 8-byte input report
} EmbeddedMacroFrame_t;
#endif

/*
 * Platform abstraction for reading macro frames from memory.
 * The generated embedded_macro.h defines MACRO_READ_FRAME for the current platform.
 *
 * AVR (PROGMEM):
 *   #define MACRO_READ_FRAME(index, dest) memcpy_P(dest, &embedded_macro_frames[index], sizeof(EmbeddedMacroFrame_t))
 *
 * Pico/ESP32 (regular const):
 *   #define MACRO_READ_FRAME(index, dest) memcpy(dest, &embedded_macro_frames[index], sizeof(EmbeddedMacroFrame_t))
 *
 * MACRO_READ_FRAME should be defined by embedded_macro.h before including this header (from the application),
 * or as a compiler flag when building macro_player.c.
 */

/*
 * Initialize the macro player.
 * Call this once during firmware startup.
 */
void macro_player_init(void);

/*
 * Get the current macro report based on elapsed time.
 *
 * This function implements the startup delay, input priming (B button press),
 * and timestamp-based macro playback with optional looping.
 *
 * Args:
 *   current_millis: Current timestamp in milliseconds (incremented by 8ms per USB poll)
 *   report: Output buffer for 8-byte report (will be filled with current macro state)
 *
 * Returns:
 *   true if macro playback is active, false during startup/priming phases
 */
bool macro_player_get_report(uint32_t current_millis, uint8_t* report);

#endif // SHARED_MACRO_PLAYER_H
